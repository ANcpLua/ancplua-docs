---
id: DATZI-090
category: concepts
slug: oauth
title: OAuth
summary: Datzi supports “subscription auth” via OAuth for providers that offer it (notably **OpenAI Codex (ChatGPT OAuth)**). For.
tags: ['concepts', 'oauth']
---

Source: https://docs.datzi.ai/concepts/oauth

# OAuth

Datzi supports “subscription auth” via OAuth for providers that offer it (notably **OpenAI Codex (ChatGPT OAuth)**). For
Anthropic subscriptions, use the **setup-token** flow. This page explains:

- how the OAuth **token exchange** works (PKCE)
- where tokens are **stored** (and why)
- how to handle **multiple accounts** (profiles + per-session overrides)

Datzi also supports **provider plugins** that ship their own OAuth or API‑key
flows. Run them via:

```bash
datzi models auth login --provider <id>
```

## The token sink (why it exists)

OAuth providers commonly mint a **new refresh token** during login/refresh flows. Some providers (or OAuth clients) can
invalidate older refresh tokens when a new one is issued for the same user/app.

Practical symptom:

- you log in via Datzi _and_ via Claude Code / Codex CLI → one of them randomly gets “logged out” later

To reduce that, Datzi treats `auth-profiles.json` as a **token sink**:

- the runtime reads credentials from **one place**
- we can keep multiple profiles and route them deterministically

## Storage (where tokens live)

Secrets are stored **per-agent**:

- Auth profiles (OAuth + API keys): `~/.datzi/agents/<agentId>/agent/auth-profiles.json`
- Runtime cache (managed automatically; don’t edit): `~/.datzi/agents/<agentId>/agent/auth.json`

Legacy import-only file (still supported, but not the main store):

- `~/.datzi/credentials/oauth.json` (imported into `auth-profiles.json` on first use)

All of the above also respect `$DATZI_STATE_DIR` (state dir override). Full
reference: [/gateway/configuration](/gateway/configuration#auth-storage-oauth--api-keys)

## OAuth exchange (how login works)

Datzi’s interactive login flows are implemented in `@mariozechner/pi-ai` and wired into the wizards/commands.

## Refresh + expiry

Profiles store an `expires` timestamp.

At runtime:

- if `expires` is in the future → use the stored access token
- if expired → refresh (under a file lock) and overwrite the stored credentials

The refresh flow is automatic; you generally don't need to manage tokens manually.

## Multiple accounts (profiles) + routing

Two patterns:

### 1) Preferred: separate agents

If you want “personal” and “work” to never interact, use isolated agents (separate sessions + credentials + workspace):

```bash
datzi agents add work
datzi agents add personal
```

Then configure auth per-agent (wizard) and route chats to the right agent.

### 2) Advanced: multiple profiles in one agent

`auth-profiles.json` supports multiple profile IDs for the same provider.

Pick which profile is used:

- globally via config ordering (`auth.order`)
- per-session via `/model ...@<profileId>`

Example (session override):

- `/model Opus@anthropic:work`

How to see what profile IDs exist:

- `datzi channels list --json` (shows `auth[]`)

Related docs:

- [/concepts/model-failover](/concepts/model-failover) (rotation + cooldown rules)
- [/tools/slash-commands](/tools/slash-commands) (command surface)

# Presence
